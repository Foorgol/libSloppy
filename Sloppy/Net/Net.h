/*
 *    This is libSloppy, a library of sloppily implemented helper functions.
 *    Copyright (C) 2016 - 2017  Volker Knollmann
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation, either version 3 of the License, or
 *    any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef SLOPPY__NET_H
#define SLOPPY__NET_H

#include <string>

#ifndef WIN32
#include <netdb.h>
#endif

#ifdef WIN32
#include <winsock2.h>   // for htonl() etc.
#endif

#include "../libSloppy.h"
#include "../Memory.h"

using namespace std;

namespace Sloppy
{
  namespace Net
  {
    class InvalidHostname{};

    using ByteString = basic_string<uint8_t>;

#ifndef WIN32
    sockaddr_in fillSockAddr(const string& hostName, int port);
#endif

    //----------------------------------------------------------------------------

    uint64_t hton_sizet(const uint64_t& in);
    uint64_t ntoh_sizet(const uint64_t& in);

    //----------------------------------------------------------------------------


    /** \brief A class for constructing a binary blob of data that consists of a sequence of simple data types (int, longs, ...)
     */
    class MessageBuilder
    {
    public:
      /** \brief Ctor for an empty message
       */
      MessageBuilder(){}

      /** \brief Appends a string to the message
       */
      void addString(
          const string& s      ///< the string to append to the message
          );

      /** \brief Appends a single byte to the message
       */
      void addByte(
          uint8_t b      ///< the byte to append to the message
          );

      /** \brief Appends an integer value to the message
       */
      void addInt(
          int i      ///< the integer to append to the message
          );

      /** \brief Appends an unsigned short (unsigned 16-bit value) to the message
       */
      void addUI16(
          uint16_t u      ///< the value to append to the message
          );

      /** \brief Appends an unsigned integer (unsigned 32-bit value) to the message
       */
      void addUI32(
          uint32_t u      ///< the value to append to the message
          );

      /** \brief Appends an unsigned long (unsigned 64-bit value) to the message
       */
      void addUI64(
          uint64_t u      ///< the value to append to the message
          );

      /** \brief Appends boolean value to the message
       *
       * The boolean value is internally converted to a single byte of either `1` or `0`
       */
      void addBool(
          bool b      ///< the value to append to the message
          )
      { addByte(b ? 1 : 0); }

      //void addManagedMemory(const ManagedMemory& mem);
      //void addByteString(const ByteString& bs);
      //void addMessageList(const vector<MessageBuilder>& msgList);
      //void rawPoke(const char* src, size_t srcLen, size_t dstOffset);

      //const ByteString& getDataAsRef() const { return data; }
      //ByteString getData() const { return data; }

      //const uint8_t* ucPtr() const { return data.c_str(); }
      //const char* charPtr() const { return (char *)data.c_str(); }
      //ManagedBuffer get() const;
      //size_t getSize() const { return data.size(); }

      /** \brief Gives view access to the message data
       *
       * \note It is the caller's responsibility that the underlying message data remains
       * valid as long as the view object is used!
       *
       * \returns an ArrayView object that points to the message data
       */
      ArrayView<uint8_t> view();

      void clear() { data.clear(); }

    private:
      ByteString data;
    };

    //----------------------------------------------------------------------------

    /** \brief A class that consumes data blobs generated by the MessageBuilder and sequentially dissects this data
     *
     * \note In order to avoid copies, this class DOES NOT OWN the data it works on. The user
     * has to ensure that the underlying data object (e.g., a string) lives at least as long
     * as the associated instance of this class is used. The only exception is if the
     * instance has been created with the static factory function `fromDataCopy()`.
     */
    class Message
    {
    public:
      /** \brief Ctor from a view on a memory array
       *
       * The new instance does NOT take ownership of the data and does not copy it.
       * The caller has to ensure that the referenced location exists long enough.
       */
      Message(const ArrayView<uint8_t>& v);

      /** \brief Ctor from a string
       *
       * The new instance does NOT take ownership of the data and does not copy it.
       * The caller has to ensure that the referenced string exists long enough.
       */
      Message(
          const string& s
          )
        : Message(ArrayView<uint8_t>(reinterpret_cast<const uint8_t*>(s.c_str()), s.size())) {}

      /** \brief Ctor from a ByteString
       *
       * The new instance does NOT take ownership of the data and does not copy it.
       * The caller has to ensure that the referenced string exists long enough.
       */
      Message(
          const ByteString& bs
          )
        : Message(ArrayView<uint8_t>(bs.c_str(), bs.size())) {}

      /** \brief Interprets the next bytes of the message as a string and extracts it from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain sufficient bytes for the read operation.
       *
       * \returns an estring containing the string data
       */
      estring getString();

      /** \brief Gets the next byte from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain sufficient bytes for the read operation.
       *
       * \returns the read byte
       */
      uint8_t getByte();

      /** \brief Interprets the next bytes of the message as an integer and extracts it from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain sufficient bytes for the read operation.
       *
       * \returns an integer containing the read data
       */
      int getInt();

      /** \brief Interprets the next bytes of the message as an UINT16 and extracts it from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain sufficient bytes for the read operation.
       *
       * \returns an UINT16 containing the read data
       */
      uint16_t getUI16();

      /** \brief Interprets the next bytes of the message as an UINT32 and extracts it from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain sufficient bytes for the read operation.
       *
       * \returns an UINT32 containing the read data
       */
      uint32_t getUI32();

      /** \brief Interprets the next bytes of the message as an UINT64 and extracts it from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain sufficient bytes for the read operation.
       *
       * \returns an UINT64 containing the read data
       */
      uint64_t getUI64();

      /** \brief Interprets the next byte of the message as a bool and extracts it from the message.
       *
       * Fast-forwards the read position in the message when the data has been read.
       *
       * \throws std::out_of_range if the message does not contain any more bytes.
       *
       * \returns a bool representing the read byte
       */
      bool getBool();

    private:
      const ArrayView<uint8_t> fullView;   ///< contains the full data view as passed to the ctor
      ArrayView<uint8_t> curView;          ///< contains a partial view that always starts at the next read position
      ByteString data;                     ///< potential internal data buffer; used only if created via `fromDataCopy`

      /** \brief Checks if the message still contains a certain number of bytes.
       *
       * \throws std::out_of_range if the message does not contain sufficient data.
       */
      void assertSufficientData(size_t n) const;
    };

    /*class InvalidMessageAccess{};

    class MessageDissector
    {
    public:
      MessageDissector(const string& s)
        :data{(uint8_t *)s.c_str(), s.size()}, offset{0} {}
      MessageDissector(const ByteString& bs)
        :data{bs}, offset{0} {}
      MessageDissector(const ManagedMemory& mm)
        :data{mm.get_uc(), mm.getSize()}, offset{0} {}

      string getString();
      uint8_t getByte();
      int getInt();
      uint16_t getUI16();
      uint32_t getUI32();
      uint64_t getUI64();
      bool getBool();
      ManagedBuffer getManagedBuffer();
      ByteString getByteString();
      vector<MessageDissector> getMessageList();

      size_t getSize() const { return data.size(); }

      // assumes that the next field is preceded with a uint64_t size header
      // returns the value of that size header
      size_t peekNextBufferSize();

    private:
      ByteString data;
      size_t offset;
      void assertSufficientData(size_t n) const;
    };

    //----------------------------------------------------------------------------

    template<typename TypeEnum>
    class TypedMessageBuilder : public MessageBuilder
    {
    public:
      TypedMessageBuilder(const TypeEnum& _msgType)
        :MessageBuilder{}, msgType{_msgType}
      {
        addInt(static_cast<int>(msgType));
      }

      void rewriteType(const TypeEnum& newType)
      {
        uint32_t networkOrder = htonl(static_cast<uint32_t>(newType));
        rawPoke((char *)&networkOrder, 4, 0);
        msgType = newType;
      }

    private:
      TypeEnum msgType;
    };


    //----------------------------------------------------------------------------

    template<typename TypeEnum>
    class TypedMessageDissector : public MessageDissector
    {
    public:
      TypedMessageDissector(const string& s)
        :MessageDissector{s}, msgType{static_cast<TypeEnum>(getInt())} {}
      TypedMessageDissector(const ByteString& bs)
        :MessageDissector{bs}, msgType{static_cast<TypeEnum>(getInt())} {}
      TypedMessageDissector(const ManagedMemory& mm)
        :MessageDissector{mm}, msgType{static_cast<TypeEnum>(getInt())} {}

      // fake-construct an empty dissector to indicate errors to the caller
      TypedMessageDissector(TypeEnum t)
        :MessageDissector{""}, msgType{t} {}

      TypeEnum getType() const { return msgType; }

    private:
      TypeEnum msgType;
    };*/
  }
}

#endif
